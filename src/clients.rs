use crate::models::{self, ClientParameterUsage};

pub const CLIENT_CONSTRUCTOR: &str = r#"package {{.CLIENT}}
// Path: client.go
//
// This file is generated by the create-go-app tool.
//
import (
	"{{.MODULE}}/pkg/services/factory"
)

type Client interface {
{{.FUNCS}}
}


type _client struct {
    baseUrl string
}

func New{{.CLIENT}}(baseUrl string) Client {
    return &_client{
        baseUrl: baseUrl,
    }
}
"#;

pub const CLIENT_FUNCTION_TEMPLATE: &str = r#"package {{.CLIENT}}
// Path: {{.FUNCTION}}.go
//
// This file is generated by the create-go-app tool.
//
import (
    "{{.MODULE}}/pkg/domains/errs"
    "{{.MODULE}}/pkg/services/factory"

    "go.uber.org/zap"
)


// {{.FUNCTION}} {{.COMMENT}}
func (c *_client) {{.FUNCTION}}(
    ftx factory.Service,{{.PARAMS}}
) {{.RETURN_SIGNATURE}} {
    
    l := ftx.Logger()

    l.Info("{{.CLIENT}}:{{.FUNCTION}}")

    res := ftx.HttpClient(
        c.baseUrl + "{{.PATH}}",
    ){{.BODY}}{{.HEADER}}{{.QUERY}}.{{.METHOD}}()

    if !res.IsSuccess() {
        body := string(res.Body())
        code := res.GetStatusCode()

        l.Error("{{.CLIENT}}:{{.FUNCTION}}:failed",
            zap.String("body",body),
            zap.Int("code",code),
        )

        return {{.RETURN_BAD}}errs.New(
            code,
            "failed to {{.FUNCTION}}",
            body,
            ftx.Traceparent(),
        )
    }

    l.Info("{{.CLIENT}}:{{.FUNCTION}}:success")
    {{.HANDLE_RESPONSE}}
	{{.RETURN_GOOD}}
}
"#;

pub const CLIENT_FUNCTION_TEMPLATE_BODY_PARSING: &str = r#"var data {{.RETURN}}

    err := res.SetResult(&data)
    if err != nil {

        l.Error("{{.CLIENT}}:{{.FUNCTION}}:failed",
            zap.Error(err),
        )

        return nil,errs.NewBadRequest(
            err.Error(),
            ftx.Traceparent(),
        )
    }

"#;


impl models::ClientContract{

    pub fn convert_to_go(&self)->String{

        let mut func = CLIENT_FUNCTION_TEMPLATE            
            .replace("{{.METHOD}}", &self.method)
            .replace("{{.HEADER}}", "")
            .replace("{{.PATH}}", &self.path.replace("{","\"+").replace("}","+\""));

		if self.return_type == "" {
			func = func.replace("{{.RETURN_SIGNATURE}}", "error");
			func = func.replace("{{.RETURN_BAD}}", "");
			func = func.replace("{{.RETURN}}", "");
			func = func.replace("{{.HANDLE_RESPONSE}}", "");
			func = func.replace("{{.RETURN_GOOD}}", "return nil");
		} else {
			func = func.replace("{{.HANDLE_RESPONSE}}", CLIENT_FUNCTION_TEMPLATE_BODY_PARSING);
			func = func.replace("{{.RETURN_SIGNATURE}}", format!("(*{},error)", self.return_type).as_str());
			func = func.replace("{{.RETURN_BAD}}", "nil,");
			func = func.replace("{{.RETURN}}", self.return_type.as_str());
			func = func.replace("{{.RETURN_GOOD}}", "return &data, nil");
		}

		func = func.replace("{{.FUNCTION}}", &self.name);


        let mut func_args = String::new();
        let mut query_args = String::new();


        for param in &self.args {
            func_args.push_str(&format!("\n\t{} {},",param.name,param.r#type.to_go()));
            if param.usage == ClientParameterUsage::QueryParameter{
                query_args.push_str(&format!(".AddQuery(\"{}\",{})",param.name,param.name));
                continue;
            }
        }

        func = func.replace("{{.QUERY}}", &query_args);

        func = func.replace("{{.COMMENT}}", &self.description.clone().unwrap_or_else(|| "".to_string()));

        if self.body.is_some() {
            func_args.push_str(&format!("\n\tcmd {},",self.body.clone().expect("body is none")));
            func = func.replace("{{.BODY}}", ".AddBody(&cmd)");
        } else {
            func = func.replace("{{.BODY}}", "");
        }

        func = func.replace("{{.PARAMS}}", &func_args);



        return func;
    }


    pub fn get_signature(&self)->String{
		let mut func_args = String::new();
		let func_return;

		for param in &self.args {
			func_args.push_str(&format!("\n\t\t{} {},", param.name, param.r#type.to_go()));
		}

		if self.body.is_some() {
			func_args.push_str(&format!("\n\t\tcmd {},", self.body.clone().expect("body is none")));
		}

		if self.return_type == "" {
			func_return = "error".to_string();
		} else {
			func_return = format!("(*{},error)", self.return_type);
		} 

		return format!("\t// {}\n\t{}(\n\t\tftx factory.Service,{func_args}\n\t) {func_return}",self.description.clone().unwrap_or_else(||"".to_string()), self.name);
	}

}




#[cfg(test)]
mod tests {
    use crate::models::ClientParameterUsageType;

    use super::*;

    #[test]
    fn test_convert_to_go() {
        let mut contract = models::ClientContract::default();
        contract.name = "test".to_string();
        contract.return_type = "string".to_string();
        contract.method = "Post".to_string();
        contract.path = "/test".to_string();
        contract.description = Some("sample test".to_string());
        contract.args.push(models::ClientParameter{
            name: "test".to_string(),
            usage: ClientParameterUsage::QueryParameter,
            r#type: ClientParameterUsageType::String,
            schema: None,
        });
        contract.body = Some("map[string]string".to_string());

        let result = contract.convert_to_go();

        println!("{}", result);

        assert_eq!(result.contains("test"), true);
        assert_eq!(result.contains("string"), true);
        assert_eq!(result.contains("Post"), true);
    }
}
